// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: metadata.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const metadataFindByDocumentId = `-- name: MetadataFindByDocumentId :many
SELECT key, value FROM metadatas WHERE document_id = $1
`

type MetadataFindByDocumentIdRow struct {
	Key   string
	Value string
}

func (q *Queries) MetadataFindByDocumentId(ctx context.Context, db DBTX, documentID pgtype.UUID) ([]*MetadataFindByDocumentIdRow, error) {
	rows, err := db.Query(ctx, metadataFindByDocumentId, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MetadataFindByDocumentIdRow
	for rows.Next() {
		var i MetadataFindByDocumentIdRow
		if err := rows.Scan(&i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const metadataFindByDocumentIds = `-- name: MetadataFindByDocumentIds :many
SELECT
    document_id,
    jsonb_object_agg(key, value) AS metadata
FROM metadatas
WHERE document_id = ANY($1::uuid[])
GROUP BY document_id
`

type MetadataFindByDocumentIdsRow struct {
	DocumentID pgtype.UUID
	Metadata   []byte
}

func (q *Queries) MetadataFindByDocumentIds(ctx context.Context, db DBTX, documentIds []pgtype.UUID) ([]*MetadataFindByDocumentIdsRow, error) {
	rows, err := db.Query(ctx, metadataFindByDocumentIds, documentIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MetadataFindByDocumentIdsRow
	for rows.Next() {
		var i MetadataFindByDocumentIdsRow
		if err := rows.Scan(&i.DocumentID, &i.Metadata); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const metadataFindByObjectIds = `-- name: MetadataFindByObjectIds :many
SELECT
    object_id,
    jsonb_object_agg(key, value) AS metadata
FROM metadatas
WHERE object_id = ANY($1::uuid[])
GROUP BY object_id
`

type MetadataFindByObjectIdsRow struct {
	ObjectID pgtype.UUID
	Metadata []byte
}

func (q *Queries) MetadataFindByObjectIds(ctx context.Context, db DBTX, objectIds []pgtype.UUID) ([]*MetadataFindByObjectIdsRow, error) {
	rows, err := db.Query(ctx, metadataFindByObjectIds, objectIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MetadataFindByObjectIdsRow
	for rows.Next() {
		var i MetadataFindByObjectIdsRow
		if err := rows.Scan(&i.ObjectID, &i.Metadata); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const metadataInsert = `-- name: MetadataInsert :one
INSERT INTO metadatas (
    object_id,
    document_id,
    key,
    value
) VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (
    COALESCE(object_id,'00000000-0000-0000-0000-000000000000'),
    COALESCE(document_id,'00000000-0000-0000-0000-000000000000'),
    key
) DO UPDATE SET value = $4
RETURNING object_id, document_id, key, value, created_at
`

type MetadataInsertParams struct {
	ObjectID   pgtype.UUID
	DocumentID pgtype.UUID
	Key        string
	Value      string
}

func (q *Queries) MetadataInsert(ctx context.Context, db DBTX, arg *MetadataInsertParams) (*Metadata, error) {
	row := db.QueryRow(ctx, metadataInsert,
		arg.ObjectID,
		arg.DocumentID,
		arg.Key,
		arg.Value,
	)
	var i Metadata
	err := row.Scan(
		&i.ObjectID,
		&i.DocumentID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
	)
	return &i, err
}

const metadataInsertBatch = `-- name: MetadataInsertBatch :one
WITH document_or_object_id AS (
  SELECT documents.id as document_id, NULL as object_id
  FROM documents
  WHERE documents.id = $1::UUID
  UNION ALL
  SELECT NULL as document_id, s3_objects.id as object_id
  FROM s3_objects
  WHERE s3_objects.id = $1::UUID
), insert_metadata AS (
  INSERT INTO metadatas (object_id, document_id, key, value)
  SELECT doid.object_id, doid.document_id, unnest($2::text[]), unnest($3::text[])
  FROM document_or_object_id as doid
  ON CONFLICT (
    COALESCE(object_id,'00000000-0000-0000-0000-000000000000'),
    COALESCE(document_id,'00000000-0000-0000-0000-000000000000'),
    key
  ) DO UPDATE SET value = EXCLUDED.value
)
SELECT document_id, object_id FROM document_or_object_id
`

type MetadataInsertBatchParams struct {
	ID     pgtype.UUID
	Keys   []string
	Values []string
}

type MetadataInsertBatchRow struct {
	DocumentID pgtype.UUID
	ObjectID   interface{}
}

func (q *Queries) MetadataInsertBatch(ctx context.Context, db DBTX, arg *MetadataInsertBatchParams) (*MetadataInsertBatchRow, error) {
	row := db.QueryRow(ctx, metadataInsertBatch, arg.ID, arg.Keys, arg.Values)
	var i MetadataInsertBatchRow
	err := row.Scan(&i.DocumentID, &i.ObjectID)
	return &i, err
}

const metadataUpdateBatch = `-- name: MetadataUpdateBatch :one
WITH document_or_object_id AS (
  SELECT documents.id as document_id, NULL as object_id
  FROM documents
  WHERE documents.id = $1::UUID
  UNION ALL
  SELECT NULL as document_id, s3_objects.id as object_id
  FROM s3_objects
  WHERE s3_objects.id = $1::UUID
), remove_unused_metadata AS (
  DELETE FROM metadatas
  WHERE (object_id = $1::UUID OR document_id = $1::UUID)
    AND key NOT IN (SELECT unnest($2::text[]))
), key_value_pairs AS (
  SELECT unnest($2::text[]) AS key, unnest($3::text[]) AS value
), insert_metadata AS (
  INSERT INTO metadatas (object_id, document_id, key, value)
  SELECT doid.object_id, doid.document_id, unnest($2::text[]), unnest($3::text[])
  FROM document_or_object_id as doid
  ON CONFLICT (
    COALESCE(object_id,'00000000-0000-0000-0000-000000000000'),
    COALESCE(document_id,'00000000-0000-0000-0000-000000000000'),
    key
  ) DO UPDATE SET value = EXCLUDED.value
)
SELECT document_id, object_id FROM document_or_object_id
`

type MetadataUpdateBatchParams struct {
	ID     pgtype.UUID
	Keys   []string
	Values []string
}

type MetadataUpdateBatchRow struct {
	DocumentID pgtype.UUID
	ObjectID   interface{}
}

func (q *Queries) MetadataUpdateBatch(ctx context.Context, db DBTX, arg *MetadataUpdateBatchParams) (*MetadataUpdateBatchRow, error) {
	row := db.QueryRow(ctx, metadataUpdateBatch, arg.ID, arg.Keys, arg.Values)
	var i MetadataUpdateBatchRow
	err := row.Scan(&i.DocumentID, &i.ObjectID)
	return &i, err
}
